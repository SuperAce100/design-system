{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ascii-wave",
  "title": "ASCII Wave",
  "description": "A flowing ASCII animation with wave-based coloring. Inspired by exa.ai.",
  "dependencies": [],
  "files": [
    {
      "path": "registry/new-york/blocks/ascii-wave/ascii-wave.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface AsciiWaveProps {\n  /** Path to the left mask image */\n  leftImage?: string;\n  /** Path to the right mask image */\n  rightImage?: string;\n  /** Character set to use for the wave animation */\n  chars?: string;\n  /** Cell width in pixels (default: 7) */\n  cellWidth?: number;\n  /** Cell height in pixels (default: 6) */\n  cellHeight?: number;\n  /** Font size in pixels (default: 6) */\n  fontSize?: number;\n  /** Animation speed multiplier (default: 1) */\n  speed?: number;\n  /** Opacity of the canvas (default: 0.9) */\n  opacity?: number;\n  /** Additional CSS classes */\n  className?: string;\n  /** Inline styles */\n  style?: React.CSSProperties;\n  /** Children to render on top of the background */\n  children?: React.ReactNode;\n}\n\n// Color gradient - deep blue through cyan to light blue\nfunction getWaveColor(t: number): { r: number; g: number; b: number } {\n  if (t <= 0.14) {\n    const e = t / 0.14;\n    return { r: 0, g: 17 + 3 * e, b: 159 + 5 * e };\n  }\n  if (t <= 0.29) {\n    const e = (t - 0.14) / 0.15;\n    return { r: 25 * e, g: 20 + 38 * e, b: 164 + 78 * e };\n  }\n  if (t <= 0.41) {\n    const e = (t - 0.29) / 0.12;\n    return { r: 25 + 36 * e, g: 58 + 54 * e, b: 242 + 9 * e };\n  }\n  if (t <= 0.53) {\n    const e = (t - 0.41) / 0.12;\n    return { r: 61 + 86 * e, g: 112 + 81 * e, b: 251 };\n  }\n  const e = (t - 0.53) / 0.47;\n  return { r: 147 + 108 * e, g: 193 + 62 * e, b: 251 + 4 * e };\n}\n\n// Color dodge blend mode\nfunction colorDodge(base: number, blend: number): number {\n  const b = base / 255;\n  const l = blend / 255;\n  if (l === 0) return 0;\n  if (l === 1) return base;\n  return Math.max(0, Math.min(255, Math.round(255 * (1 - (1 - b) / l))));\n}\n\nexport function AsciiWave({\n  leftImage = \"/images/backgrounds/mountain-l-color.png\",\n  rightImage = \"/images/backgrounds/mountain-r-color.png\",\n  chars = \"▅▃▁?ab018:. \",\n  cellWidth = 7,\n  cellHeight = 6,\n  fontSize = 6,\n  speed = 1,\n  opacity = 0.9,\n  className,\n  style,\n  children,\n}: AsciiWaveProps) {\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const animationRef = React.useRef<number>(0);\n  const startTimeRef = React.useRef<number>(0);\n\n  // Image refs\n  const leftImageRef = React.useRef<HTMLImageElement | null>(null);\n  const rightImageRef = React.useRef<HTMLImageElement | null>(null);\n  const leftImageDataRef = React.useRef<ImageData | null>(null);\n  const rightImageDataRef = React.useRef<ImageData | null>(null);\n\n  const { sin, floor, PI } = Math;\n  const TAU = 2 * PI;\n\n  // Generate ASCII character based on position and time\n  const getChar = React.useCallback(\n    (\n      pos: { x: number; y: number },\n      state: { time: number; cols: number; rows: number }\n    ): string => {\n      const time = 1e-4 * state.time * speed;\n      const scale = Math.min(state.cols, state.rows);\n      const normalized = {\n        x: (2 * (pos.x - state.cols / 2)) / scale,\n        y: (2 * (pos.y - state.rows / 2)) / scale,\n      };\n      const index =\n        floor(\n          (0.5 * sin(4 * (normalized.y - 0.5 * time)) +\n            0.5 +\n            0.1 * sin(3 * normalized.x)) *\n            chars.length\n        ) % chars.length;\n      return chars[Math.abs(index)];\n    },\n    [chars, speed, sin, floor]\n  );\n\n  // Main render loop\n  const render = React.useCallback(\n    (timestamp: number) => {\n      if (!canvasRef.current) return;\n      if (!startTimeRef.current) startTimeRef.current = timestamp;\n\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext(\"2d\");\n      if (!ctx) return;\n\n      const container = containerRef.current;\n      if (!container) return;\n\n      const rect = container.getBoundingClientRect();\n      const screenWidth = rect.width;\n      const screenHeight = rect.height;\n      const dpr = window.devicePixelRatio || 1;\n\n      canvas.width = screenWidth * dpr;\n      canvas.height = screenHeight * dpr;\n      ctx.scale(dpr, dpr);\n\n      ctx.fillStyle = \"transparent\";\n      ctx.fillRect(0, 0, screenWidth, screenHeight);\n\n      const cols = Math.floor(screenWidth / cellWidth);\n      const rows = Math.floor(screenHeight / cellHeight);\n      const state = {\n        time: timestamp - startTimeRef.current,\n        cols,\n        rows,\n      };\n\n      // Calculate layouts for both images\n      type ImageLayout = {\n        x: number;\n        y: number;\n        width: number;\n        height: number;\n      };\n\n      let leftLayout: ImageLayout | null = null;\n      let rightLayout: ImageLayout | null = null;\n\n      // Left image layout\n      if (leftImageRef.current) {\n        const img = leftImageRef.current;\n        const imgAspect = img.width / img.height;\n        let drawWidth: number, drawHeight: number;\n\n        drawHeight = 0.85 * screenHeight;\n        drawWidth = drawHeight * imgAspect;\n\n        leftLayout = {\n          x: 0,\n          y: screenHeight / 2 - drawHeight / 2 - 0.1 * screenHeight,\n          width: drawWidth,\n          height: drawHeight,\n        };\n      }\n\n      // Right image layout\n      if (rightImageRef.current) {\n        const img = rightImageRef.current;\n        const imgAspect = img.width / img.height;\n        let drawWidth: number, drawHeight: number;\n\n        drawHeight = 0.85 * screenHeight;\n        drawWidth = drawHeight * imgAspect;\n\n        rightLayout = {\n          x: screenWidth - drawWidth,\n          y: screenHeight / 2 - drawHeight / 2 - 0.1 * screenHeight,\n          width: drawWidth,\n          height: drawHeight,\n        };\n      }\n\n      // Draw images\n      ctx.save();\n      ctx.globalAlpha = 0.4;\n\n      if (leftImageRef.current && leftLayout) {\n        ctx.drawImage(\n          leftImageRef.current,\n          leftLayout.x,\n          leftLayout.y,\n          leftLayout.width,\n          leftLayout.height\n        );\n      }\n\n      if (rightImageRef.current && rightLayout) {\n        ctx.drawImage(\n          rightImageRef.current,\n          rightLayout.x,\n          rightLayout.y,\n          rightLayout.width,\n          rightLayout.height\n        );\n      }\n\n      ctx.restore();\n\n      // Apply top gradient fade\n      ctx.save();\n      const gradient = ctx.createLinearGradient(0, 0, 0, screenHeight);\n      gradient.addColorStop(0, \"rgba(255, 255, 255, 1)\");\n      gradient.addColorStop(0.15, \"rgba(255, 255, 255, 0)\");\n      gradient.addColorStop(1, \"rgba(255, 255, 255, 0)\");\n      ctx.globalCompositeOperation = \"destination-out\";\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, screenWidth, screenHeight);\n      ctx.restore();\n\n      // Setup text rendering\n      ctx.font = `${fontSize}px monospace`;\n      ctx.textAlign = \"left\";\n      ctx.textBaseline = \"top\";\n\n      const baseColor = { r: 231, g: 235, b: 237 };\n\n      // Render ASCII grid\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const char = getChar({ x: col, y: row }, state);\n\n          if (row > 0.75 * rows) continue;\n\n          const normalizedRow = row / (0.75 * rows);\n          let charOpacity = 0;\n\n          const pixelX = cellWidth * col;\n          const pixelY = cellHeight * row;\n\n          // Sample left image\n          if (leftImageRef.current && leftImageDataRef.current && leftLayout) {\n            const img = leftImageRef.current;\n            if (\n              pixelX >= leftLayout.x &&\n              pixelX <= leftLayout.x + leftLayout.width &&\n              pixelY >= leftLayout.y &&\n              pixelY <= leftLayout.y + leftLayout.height\n            ) {\n              const sampleX = Math.floor(\n                ((pixelX - leftLayout.x) / leftLayout.width) * img.width\n              );\n              const sampleY = Math.floor(\n                ((pixelY - leftLayout.y) / leftLayout.height) * img.height\n              );\n\n              if (\n                sampleX >= 0 &&\n                sampleX < img.width &&\n                sampleY >= 0 &&\n                sampleY < img.height\n              ) {\n                const pixelIndex = (sampleY * img.width + sampleX) * 4;\n                const r = leftImageDataRef.current.data[pixelIndex];\n                const g = leftImageDataRef.current.data[pixelIndex + 1];\n                const b = leftImageDataRef.current.data[pixelIndex + 2];\n                const luminance = (r + g + b) / 3;\n\n                if (luminance >= 230) {\n                  charOpacity = 0;\n                } else if (luminance >= 200) {\n                  charOpacity = Math.pow(1 - (luminance - 200) / 30, 2);\n                } else {\n                  charOpacity = Math.pow(1 - luminance / 200, 0.3);\n                }\n              }\n            }\n          }\n\n          // Sample right image\n          if (\n            rightImageRef.current &&\n            rightImageDataRef.current &&\n            rightLayout\n          ) {\n            const img = rightImageRef.current;\n            if (\n              pixelX >= rightLayout.x &&\n              pixelX <= rightLayout.x + rightLayout.width &&\n              pixelY >= rightLayout.y &&\n              pixelY <= rightLayout.y + rightLayout.height\n            ) {\n              const sampleX = Math.floor(\n                ((pixelX - rightLayout.x) / rightLayout.width) * img.width\n              );\n              const sampleY = Math.floor(\n                ((pixelY - rightLayout.y) / rightLayout.height) * img.height\n              );\n\n              if (\n                sampleX >= 0 &&\n                sampleX < img.width &&\n                sampleY >= 0 &&\n                sampleY < img.height\n              ) {\n                const pixelIndex = (sampleY * img.width + sampleX) * 4;\n                const r = rightImageDataRef.current.data[pixelIndex];\n                const g = rightImageDataRef.current.data[pixelIndex + 1];\n                const b = rightImageDataRef.current.data[pixelIndex + 2];\n                const luminance = (r + g + b) / 3;\n\n                if (luminance >= 230) {\n                  charOpacity = Math.max(charOpacity, 0);\n                } else if (luminance >= 200) {\n                  charOpacity = Math.max(\n                    charOpacity,\n                    Math.pow(1 - (luminance - 200) / 30, 2)\n                  );\n                } else {\n                  charOpacity = Math.max(\n                    charOpacity,\n                    Math.pow(1 - luminance / 200, 0.3)\n                  );\n                }\n              }\n            }\n          }\n\n          // Fade at top\n          let topFade = 1;\n          if (normalizedRow < 0.15) {\n            topFade = normalizedRow / 0.15;\n          }\n          charOpacity *= topFade;\n\n          // Only render if visible\n          if (charOpacity > 0.025) {\n            const waveValue = 0.5 * sin(3 * normalizedRow * TAU) + 0.5;\n            const waveColor = getWaveColor(waveValue);\n\n            const blended = {\n              r: colorDodge(baseColor.r, waveColor.r),\n              g: colorDodge(baseColor.g, waveColor.g),\n              b: colorDodge(baseColor.b, waveColor.b),\n            };\n\n            const finalColor = {\n              r: Math.round(baseColor.r + (blended.r - baseColor.r) * 0.8),\n              g: Math.round(baseColor.g + (blended.g - baseColor.g) * 0.8),\n              b: Math.round(baseColor.b + (blended.b - baseColor.b) * 0.8),\n            };\n\n            ctx.fillStyle = `rgba(${finalColor.r}, ${finalColor.g}, ${finalColor.b}, ${charOpacity})`;\n            ctx.fillText(char, cellWidth * col, cellHeight * row);\n          }\n        }\n      }\n\n      animationRef.current = requestAnimationFrame(render);\n    },\n    [getChar, cellWidth, cellHeight, fontSize, sin, TAU]\n  );\n\n  // Load left image\n  React.useEffect(() => {\n    if (!leftImage) return;\n\n    const img = new Image();\n    img.src = leftImage;\n    img.onload = () => {\n      leftImageRef.current = img;\n\n      const tempCanvas = document.createElement(\"canvas\");\n      tempCanvas.width = img.width;\n      tempCanvas.height = img.height;\n      const tempCtx = tempCanvas.getContext(\"2d\");\n      if (tempCtx) {\n        tempCtx.drawImage(img, 0, 0);\n        try {\n          leftImageDataRef.current = tempCtx.getImageData(\n            0,\n            0,\n            img.width,\n            img.height\n          );\n        } catch (e) {\n          console.error(\"Failed to extract left image data:\", e);\n        }\n      }\n    };\n  }, [leftImage]);\n\n  // Load right image\n  React.useEffect(() => {\n    if (!rightImage) return;\n\n    const img = new Image();\n    img.src = rightImage;\n    img.onload = () => {\n      rightImageRef.current = img;\n\n      const tempCanvas = document.createElement(\"canvas\");\n      tempCanvas.width = img.width;\n      tempCanvas.height = img.height;\n      const tempCtx = tempCanvas.getContext(\"2d\");\n      if (tempCtx) {\n        tempCtx.drawImage(img, 0, 0);\n        try {\n          rightImageDataRef.current = tempCtx.getImageData(\n            0,\n            0,\n            img.width,\n            img.height\n          );\n        } catch (e) {\n          console.error(\"Failed to extract right image data:\", e);\n        }\n      }\n    };\n  }, [rightImage]);\n\n  // Start animation\n  React.useEffect(() => {\n    if (!canvasRef.current) return;\n\n    animationRef.current = requestAnimationFrame(render);\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [render]);\n\n  // Handle resize\n  React.useEffect(() => {\n    const handleResize = () => {\n      startTimeRef.current = 0;\n    };\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(\"relative w-full h-full overflow-hidden\", className)}\n      style={style}\n    >\n      <canvas\n        ref={canvasRef}\n        className=\"absolute inset-0 w-full h-full pointer-events-none\"\n        style={{ opacity }}\n      />\n      {children && <div className=\"relative z-10 h-full\">{children}</div>}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/ui/ascii-wave.tsx"
    }
  ],
  "type": "registry:component"
}