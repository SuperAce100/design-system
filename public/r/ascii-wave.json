{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "ascii-wave",
  "title": "ASCII Wave",
  "description": "A flowing ASCII animation with wave-based coloring. Inspired by exa.ai.",
  "dependencies": [],
  "files": [
    {
      "path": "registry/new-york/blocks/ascii-wave/ascii-wave.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\nexport interface AsciiWaveProps {\n  /** Path to the mask image (mountain silhouette) */\n  maskImage?: string;\n  /** Character set to use for the wave animation */\n  chars?: string;\n  /** Cell width in pixels (default: 7) */\n  cellWidth?: number;\n  /** Cell height in pixels (default: 6) */\n  cellHeight?: number;\n  /** Font size in pixels (default: 6) */\n  fontSize?: number;\n  /** Animation speed multiplier (default: 1) */\n  speed?: number;\n  /** Opacity of the canvas (default: 0.9) */\n  opacity?: number;\n  /** Additional CSS classes */\n  className?: string;\n  /** Inline styles */\n  style?: React.CSSProperties;\n  /** Children to render on top of the background */\n  children?: React.ReactNode;\n}\n\n// Color gradient - deep blue through cyan to light blue\nfunction getWaveColor(t: number): { r: number; g: number; b: number } {\n  if (t <= 0.14) {\n    const e = t / 0.14;\n    return { r: 0, g: 17 + 3 * e, b: 159 + 5 * e };\n  }\n  if (t <= 0.29) {\n    const e = (t - 0.14) / 0.15;\n    return { r: 25 * e, g: 20 + 38 * e, b: 164 + 78 * e };\n  }\n  if (t <= 0.41) {\n    const e = (t - 0.29) / 0.12;\n    return { r: 25 + 36 * e, g: 58 + 54 * e, b: 242 + 9 * e };\n  }\n  if (t <= 0.53) {\n    const e = (t - 0.41) / 0.12;\n    return { r: 61 + 86 * e, g: 112 + 81 * e, b: 251 };\n  }\n  const e = (t - 0.53) / 0.47;\n  return { r: 147 + 108 * e, g: 193 + 62 * e, b: 251 + 4 * e };\n}\n\n// Color dodge blend mode\nfunction colorDodge(base: number, blend: number): number {\n  const b = base / 255;\n  const l = blend / 255;\n  if (l === 0) return 0;\n  if (l === 1) return base;\n  return Math.max(0, Math.min(255, Math.round(255 * (1 - (1 - b) / l))));\n}\n\nexport function AsciiWave({\n  maskImage = \"/images/backgrounds/mountain-r-color.png\",\n  chars = \"▅▃▁?ab018:. \",\n  cellWidth = 7,\n  cellHeight = 6,\n  fontSize = 6,\n  speed = 1,\n  opacity = 0.9,\n  className,\n  style,\n  children,\n}: AsciiWaveProps) {\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const animationRef = React.useRef<number>(0);\n  const startTimeRef = React.useRef<number>(0);\n\n  // Image refs - no rotation, just store the original\n  const imageRef = React.useRef<HTMLImageElement | null>(null);\n  const imageDataRef = React.useRef<ImageData | null>(null);\n\n  const { sin, floor, PI } = Math;\n  const TAU = 2 * PI;\n\n  // Generate ASCII character based on position and time\n  const getChar = React.useCallback(\n    (\n      pos: { x: number; y: number },\n      state: { time: number; cols: number; rows: number }\n    ): string => {\n      const time = 1e-4 * state.time * speed;\n      const scale = Math.min(state.cols, state.rows);\n      const normalized = {\n        x: (2 * (pos.x - state.cols / 2)) / scale,\n        y: (2 * (pos.y - state.rows / 2)) / scale,\n      };\n      const index =\n        floor(\n          (0.5 * sin(4 * (normalized.y - 0.5 * time)) +\n            0.5 +\n            0.1 * sin(3 * normalized.x)) *\n            chars.length\n        ) % chars.length;\n      return chars[Math.abs(index)];\n    },\n    [chars, speed, sin, floor]\n  );\n\n  // Main render loop\n  const render = React.useCallback(\n    (timestamp: number) => {\n      if (!canvasRef.current) return;\n      if (!startTimeRef.current) startTimeRef.current = timestamp;\n\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext(\"2d\");\n      if (!ctx) return;\n\n      const container = containerRef.current;\n      if (!container) return;\n\n      const rect = container.getBoundingClientRect();\n      const screenWidth = rect.width;\n      const screenHeight = rect.height;\n      const dpr = window.devicePixelRatio || 1;\n\n      canvas.width = screenWidth * dpr;\n      canvas.height = screenHeight * dpr;\n      ctx.scale(dpr, dpr);\n\n      ctx.fillStyle = \"transparent\";\n      ctx.fillRect(0, 0, screenWidth, screenHeight);\n\n      const cols = Math.floor(screenWidth / cellWidth);\n      const rows = Math.floor(screenHeight / cellHeight);\n      const state = {\n        time: timestamp - startTimeRef.current,\n        cols,\n        rows,\n      };\n\n      // Calculate image layout\n      type ImageLayout = {\n        leftEdgeX: number;\n        rightEdgeX: number;\n        drawWidth: number;\n        drawHeight: number;\n        centerY: number;\n      };\n      let imageLayout: ImageLayout | null = null;\n\n      if (imageRef.current) {\n        const img = imageRef.current;\n        const imgAspect = img.width / img.height;\n\n        // Scale image to fit 85% of screen while maintaining aspect ratio\n        let drawWidth: number;\n        let drawHeight: number;\n\n        if (imgAspect > screenWidth / screenHeight) {\n          drawWidth = 0.85 * screenWidth;\n          drawHeight = drawWidth / imgAspect;\n        } else {\n          drawHeight = 0.85 * screenHeight;\n          drawWidth = drawHeight * imgAspect;\n        }\n\n        imageLayout = {\n          leftEdgeX: 0.05 * screenWidth,\n          rightEdgeX: 0.95 * screenWidth,\n          drawWidth,\n          drawHeight,\n          centerY: screenHeight / 2 - 0.1 * screenHeight,\n        };\n      }\n\n      // Draw images on sides (no rotation - just positioned on edges)\n      if (imageRef.current && imageLayout) {\n        ctx.save();\n        ctx.globalAlpha = 0.4;\n\n        const img = imageRef.current;\n        const { drawWidth, drawHeight, leftEdgeX, rightEdgeX, centerY } =\n          imageLayout;\n\n        // Draw on left side\n        ctx.drawImage(\n          img,\n          leftEdgeX,\n          centerY - drawHeight / 2,\n          drawWidth,\n          drawHeight\n        );\n\n        // Draw on right side (flipped horizontally)\n        ctx.save();\n        ctx.translate(rightEdgeX, centerY);\n        ctx.scale(-1, 1);\n        ctx.drawImage(img, 0, -drawHeight / 2, drawWidth, drawHeight);\n        ctx.restore();\n\n        ctx.restore();\n\n        // Apply top gradient fade\n        ctx.save();\n        const gradient = ctx.createLinearGradient(0, 0, 0, screenHeight);\n        gradient.addColorStop(0, \"rgba(255, 255, 255, 1)\");\n        gradient.addColorStop(0.15, \"rgba(255, 255, 255, 0)\");\n        gradient.addColorStop(1, \"rgba(255, 255, 255, 0)\");\n        ctx.globalCompositeOperation = \"destination-out\";\n        ctx.fillStyle = gradient;\n        ctx.fillRect(0, 0, screenWidth, screenHeight);\n        ctx.restore();\n      }\n\n      // Setup text rendering\n      ctx.font = `${fontSize}px monospace`;\n      ctx.textAlign = \"left\";\n      ctx.textBaseline = \"top\";\n\n      const baseColor = { r: 231, g: 235, b: 237 };\n\n      // Render ASCII grid\n      for (let row = 0; row < rows; row++) {\n        for (let col = 0; col < cols; col++) {\n          const char = getChar({ x: col, y: row }, state);\n\n          // Skip bottom 25% of rows\n          if (row > 0.75 * rows) continue;\n\n          const normalizedRow = row / (0.75 * rows);\n          let charOpacity = 1;\n\n          // Sample image for opacity if available\n          if (imageDataRef.current && imageRef.current && imageLayout) {\n            const imgWidth = imageRef.current.width;\n            const imgHeight = imageRef.current.height;\n            const pixelX = cellWidth * col;\n            const pixelY = cellHeight * row;\n\n            let sampleX = -1;\n            let sampleY = -1;\n\n            const { drawWidth, drawHeight, leftEdgeX, rightEdgeX, centerY } =\n              imageLayout;\n\n            // Left image region\n            const leftRegionX = leftEdgeX;\n            const leftRegionXEnd = leftEdgeX + drawWidth;\n            const leftRegionY = centerY - drawHeight / 2;\n            const leftRegionYEnd = centerY + drawHeight / 2;\n\n            if (\n              pixelX >= leftRegionX &&\n              pixelX <= leftRegionXEnd &&\n              pixelY >= leftRegionY &&\n              pixelY <= leftRegionYEnd\n            ) {\n              sampleX = Math.floor(\n                ((pixelX - leftRegionX) / drawWidth) * imgWidth\n              );\n              sampleY = Math.floor(\n                ((pixelY - leftRegionY) / drawHeight) * imgHeight\n              );\n            }\n\n            // Right image region (flipped)\n            const rightRegionX = rightEdgeX - drawWidth;\n            const rightRegionXEnd = rightEdgeX;\n            const rightRegionY = centerY - drawHeight / 2;\n            const rightRegionYEnd = centerY + drawHeight / 2;\n\n            if (\n              pixelX >= rightRegionX &&\n              pixelX <= rightRegionXEnd &&\n              pixelY >= rightRegionY &&\n              pixelY <= rightRegionYEnd\n            ) {\n              // Flip X for right side\n              sampleX = Math.floor(\n                ((rightRegionXEnd - pixelX) / drawWidth) * imgWidth\n              );\n              sampleY = Math.floor(\n                ((pixelY - rightRegionY) / drawHeight) * imgHeight\n              );\n            }\n\n            // Sample pixel and calculate opacity based on luminance\n            if (\n              sampleX >= 0 &&\n              sampleX < imgWidth &&\n              sampleY >= 0 &&\n              sampleY < imgHeight\n            ) {\n              const pixelIndex = (sampleY * imgWidth + sampleX) * 4;\n              const r = imageDataRef.current.data[pixelIndex];\n              const g = imageDataRef.current.data[pixelIndex + 1];\n              const b = imageDataRef.current.data[pixelIndex + 2];\n              const luminance = (r + g + b) / 3;\n\n              if (luminance >= 230) {\n                charOpacity = 0;\n              } else if (luminance >= 200) {\n                charOpacity = Math.pow(1 - (luminance - 200) / 30, 2);\n              } else {\n                charOpacity = Math.pow(1 - luminance / 200, 0.3);\n              }\n            }\n          }\n\n          // Determine if pixel is in image region\n          let inImageRegion = 0;\n          if (imageRef.current && imageLayout) {\n            const pixelX = cellWidth * col;\n            const pixelY = cellHeight * row;\n\n            const { drawWidth, drawHeight, leftEdgeX, rightEdgeX, centerY } =\n              imageLayout;\n\n            // Left region\n            const inLeft =\n              pixelX >= leftEdgeX &&\n              pixelX <= leftEdgeX + drawWidth &&\n              pixelY >= centerY - drawHeight / 2 &&\n              pixelY <= centerY + drawHeight / 2;\n\n            // Right region\n            const inRight =\n              pixelX >= rightEdgeX - drawWidth &&\n              pixelX <= rightEdgeX &&\n              pixelY >= centerY - drawHeight / 2 &&\n              pixelY <= centerY + drawHeight / 2;\n\n            if (inLeft || inRight) {\n              inImageRegion = charOpacity;\n            }\n          }\n\n          // Fade at top\n          let topFade = 1;\n          if (normalizedRow < 0.15) {\n            topFade = normalizedRow / 0.15;\n          }\n          inImageRegion *= topFade;\n\n          // Only render if visible\n          if (inImageRegion > 0.025) {\n            // Wave-based coloring\n            const waveValue = 0.5 * sin(3 * normalizedRow * TAU) + 0.5;\n            const waveColor = getWaveColor(waveValue);\n\n            // Color dodge blending\n            const blended = {\n              r: colorDodge(baseColor.r, waveColor.r),\n              g: colorDodge(baseColor.g, waveColor.g),\n              b: colorDodge(baseColor.b, waveColor.b),\n            };\n\n            // Mix colors\n            const finalColor = {\n              r: Math.round(baseColor.r + (blended.r - baseColor.r) * 0.8),\n              g: Math.round(baseColor.g + (blended.g - baseColor.g) * 0.8),\n              b: Math.round(baseColor.b + (blended.b - baseColor.b) * 0.8),\n            };\n\n            ctx.fillStyle = `rgba(${finalColor.r}, ${finalColor.g}, ${finalColor.b}, ${inImageRegion})`;\n            ctx.fillText(char, cellWidth * col, cellHeight * row);\n          }\n        }\n      }\n\n      animationRef.current = requestAnimationFrame(render);\n    },\n    [getChar, cellWidth, cellHeight, fontSize, sin, TAU]\n  );\n\n  // Load image (no rotation)\n  React.useEffect(() => {\n    if (!maskImage) return;\n\n    const img = new Image();\n    img.src = maskImage;\n    img.onload = () => {\n      imageRef.current = img;\n\n      // Extract pixel data for sampling\n      const tempCanvas = document.createElement(\"canvas\");\n      tempCanvas.width = img.width;\n      tempCanvas.height = img.height;\n      const tempCtx = tempCanvas.getContext(\"2d\");\n      if (tempCtx) {\n        tempCtx.drawImage(img, 0, 0);\n        try {\n          imageDataRef.current = tempCtx.getImageData(\n            0,\n            0,\n            img.width,\n            img.height\n          );\n        } catch (e) {\n          console.error(\"Failed to extract image data:\", e);\n        }\n      }\n    };\n    img.onerror = () => {\n      console.error(\"Failed to load mask image:\", maskImage);\n    };\n  }, [maskImage]);\n\n  // Start animation\n  React.useEffect(() => {\n    if (!canvasRef.current) return;\n\n    animationRef.current = requestAnimationFrame(render);\n\n    return () => {\n      if (animationRef.current) {\n        cancelAnimationFrame(animationRef.current);\n      }\n    };\n  }, [render]);\n\n  // Handle resize\n  React.useEffect(() => {\n    const handleResize = () => {\n      startTimeRef.current = 0;\n    };\n\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(\"relative w-full h-full overflow-hidden\", className)}\n      style={style}\n    >\n      <canvas\n        ref={canvasRef}\n        className=\"absolute inset-0 w-full h-full pointer-events-none\"\n        style={{ opacity }}\n      />\n      {children && <div className=\"relative z-10 h-full\">{children}</div>}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/ui/ascii-wave.tsx"
    }
  ],
  "type": "registry:component"
}