{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "shader-background",
  "title": "Shader Background",
  "description": "An ethereal, flowing WebGL background with subtle animation. Inspired by exa.ai.",
  "dependencies": [],
  "files": [
    {
      "path": "registry/new-york/blocks/shader-background/shader-background.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\n// Vertex shader\nconst vertexShaderSource = `#version 300 es\nin vec4 a_position;\nout vec2 v_texCoord;\n\nvoid main() {\n  gl_Position = a_position;\n  v_texCoord = a_position.xy * 0.5 + 0.5;\n}`;\n\n// Fragment shader for ethereal flowing background\n// Features: two main marble wisps, flowing veined texture, saturation variation, framing effect\nconst fragmentShaderSource = `#version 300 es\nprecision highp float;\n\nin vec2 v_texCoord;\nout vec4 fragColor;\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform float u_noiseScale;\nuniform float u_flowSpeed;\nuniform float u_edgeFade;\n\n// Hash for dithering\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Simplex 2D noise\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                      -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n                   + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                          dot(x12.zw,x12.zw)), 0.0);\n  m = m*m;\n  m = m*m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// FBM for marble texture\nfloat fbm(vec2 p, float time) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n  \n  for (int i = 0; i < 6; i++) {\n    value += amplitude * snoise(p * frequency + vec2(0.0, time * 0.02));\n    frequency *= 2.0;\n    amplitude *= 0.5;\n  }\n  \n  return value;\n}\n\n// Domain warping for marble effect\nvec2 warp(vec2 p, float time) {\n  vec2 q = vec2(\n    fbm(p + vec2(0.0, 0.0), time),\n    fbm(p + vec2(5.2, 1.3), time)\n  );\n  \n  vec2 r = vec2(\n    fbm(p + 4.0 * q + vec2(1.7, 9.2), time),\n    fbm(p + 4.0 * q + vec2(8.3, 2.8), time)\n  );\n  \n  return r;\n}\n\n// Marble veining pattern\nfloat marble(vec2 p, float time) {\n  vec2 w = warp(p * 0.5, time);\n  float n = fbm(p + 2.0 * w, time);\n  \n  // Create veining effect\n  float veins = sin((p.x + p.y * 0.5 + n * 3.0) * 3.14159);\n  veins = pow(abs(veins), 0.3);\n  \n  return mix(n * 0.5 + 0.5, veins, 0.6);\n}\n\n// Bayer dithering\nfloat bayerDither(vec2 pos) {\n  vec2 p = mod(pos, 8.0);\n  float a = mod(p.x + p.y * 2.0, 4.0);\n  float b = mod(p.x * 2.0 + p.y, 4.0);\n  return (a * 4.0 + b) / 64.0;\n}\n\nvoid main() {\n  vec2 uv = v_texCoord;\n  float aspect = u_resolution.x / u_resolution.y;\n  \n  float time = u_time * u_flowSpeed;\n  \n  // Pixelation for dithered texture\n  float pixelSize = 2.0;\n  vec2 pixelCoord = uv * u_resolution;\n  vec2 pixelUV = floor(pixelCoord / pixelSize) * pixelSize / u_resolution;\n  vec2 ditherCoord = floor(pixelCoord / pixelSize);\n  \n  // Scale for noise\n  vec2 noiseUV = vec2(pixelUV.x * aspect, pixelUV.y) * u_noiseScale;\n  \n  // === LEFT WISP - Curving ribbon that frames the left side ===\n  float leftWarp = fbm(noiseUV * 1.2 + vec2(time * 0.02, 0.0), time);\n  float leftWarp2 = fbm(noiseUV * 2.0 + vec2(-1.0, time * 0.015), time);\n  \n  // Main ribbon - curves inward from left edge, flows vertically\n  float leftCurveBase = 0.12 + sin(pixelUV.y * 2.5) * 0.08 + leftWarp * 0.1;\n  float leftX = pixelUV.x - leftCurveBase;\n  \n  // Create flowing ribbon shape\n  float leftRibbonInner = smoothstep(-0.02, 0.15, leftX);\n  float leftRibbonOuter = smoothstep(0.35, 0.1, leftX);\n  float leftRibbon = leftRibbonInner * leftRibbonOuter;\n  \n  // Add multiple thin vertical streaming lines within ribbon\n  float leftStream1 = sin(pixelUV.y * 15.0 + leftWarp * 6.0 + pixelUV.x * 10.0) * 0.5 + 0.5;\n  float leftStream2 = sin(pixelUV.y * 22.0 + leftWarp2 * 4.0 - pixelUV.x * 7.0) * 0.5 + 0.5;\n  float leftStream3 = sin(pixelUV.y * 28.0 + leftWarp * 3.0 + pixelUV.x * 12.0) * 0.5 + 0.5;\n  float leftStream4 = sin(pixelUV.y * 35.0 - leftWarp2 * 5.0 + pixelUV.x * 15.0) * 0.5 + 0.5;\n  float leftStreams = smoothstep(0.7, 0.96, leftStream1) * 0.6 + \n                      smoothstep(0.72, 0.95, leftStream2) * 0.5 +\n                      smoothstep(0.75, 0.97, leftStream3) * 0.4 +\n                      smoothstep(0.78, 0.98, leftStream4) * 0.3;\n  \n  // Marble texture\n  float leftMarble = marble(noiseUV + vec2(-2.0, 0.0), time);\n  float leftVein = marble(noiseUV * 1.5 + vec2(-1.0, 1.0), time * 0.8);\n  \n  // Flowing tendrils curving around\n  float leftTendril1 = sin(pixelUV.y * 8.0 + leftWarp * 4.0 + pixelUV.x * 12.0) * 0.5 + 0.5;\n  leftTendril1 = smoothstep(0.72, 0.98, leftTendril1) * pow(max(0.0, 0.3 - pixelUV.x), 1.3);\n  \n  float leftTendril2 = sin(pixelUV.y * 14.0 + leftVein * 3.0 - pixelUV.x * 6.0 + time * 0.3) * 0.5 + 0.5;\n  leftTendril2 = smoothstep(0.75, 0.98, leftTendril2) * pow(max(0.0, 0.25 - pixelUV.x), 1.5);\n  \n  // Combine left wisp\n  float leftBase = leftRibbon * (0.6 + leftMarble * 0.4 + leftStreams * 0.3);\n  float leftTendrils = leftTendril1 * 2.5 + leftTendril2 * 2.0;\n  float leftIntensity = leftBase + leftTendrils * 0.5;\n  leftIntensity *= smoothstep(0.7, 0.0, pixelUV.x); // Fade toward center\n  \n  // === RIGHT WISP - Curving ribbon that frames the right side ===\n  float rightWarp = fbm(noiseUV * 1.2 + vec2(5.0, time * 0.02), time);\n  float rightWarp2 = fbm(noiseUV * 2.0 + vec2(6.0, time * 0.015), time);\n  \n  // Mirror the curve for right side\n  float rightCurveBase = 0.12 + sin((1.0 - pixelUV.y) * 2.5) * 0.08 + rightWarp * 0.1;\n  float rightX = (1.0 - pixelUV.x) - rightCurveBase;\n  \n  // Create flowing ribbon shape\n  float rightRibbonInner = smoothstep(-0.02, 0.15, rightX);\n  float rightRibbonOuter = smoothstep(0.35, 0.1, rightX);\n  float rightRibbon = rightRibbonInner * rightRibbonOuter;\n  \n  // Add multiple thin vertical streaming lines\n  float rightStream1 = sin((1.0 - pixelUV.y) * 15.0 + rightWarp * 6.0 + (1.0 - pixelUV.x) * 10.0) * 0.5 + 0.5;\n  float rightStream2 = sin((1.0 - pixelUV.y) * 21.0 + rightWarp2 * 4.0 - (1.0 - pixelUV.x) * 7.0) * 0.5 + 0.5;\n  float rightStream3 = sin((1.0 - pixelUV.y) * 27.0 + rightWarp * 3.0 + (1.0 - pixelUV.x) * 12.0) * 0.5 + 0.5;\n  float rightStream4 = sin((1.0 - pixelUV.y) * 34.0 - rightWarp2 * 5.0 + (1.0 - pixelUV.x) * 14.0) * 0.5 + 0.5;\n  float rightStreams = smoothstep(0.7, 0.96, rightStream1) * 0.6 + \n                       smoothstep(0.72, 0.95, rightStream2) * 0.5 +\n                       smoothstep(0.75, 0.97, rightStream3) * 0.4 +\n                       smoothstep(0.78, 0.98, rightStream4) * 0.3;\n  \n  // Marble texture\n  float rightMarble = marble(noiseUV + vec2(3.0, 1.0), time * 0.9);\n  float rightVein = marble(noiseUV * 1.4 + vec2(4.0, -1.0), time * 0.7);\n  \n  // Flowing tendrils\n  float rightTendril1 = sin((1.0 - pixelUV.y) * 8.0 + rightWarp * 4.0 + (1.0 - pixelUV.x) * 12.0) * 0.5 + 0.5;\n  rightTendril1 = smoothstep(0.72, 0.98, rightTendril1) * pow(max(0.0, pixelUV.x - 0.7), 1.3);\n  \n  float rightTendril2 = sin((1.0 - pixelUV.y) * 13.0 + rightVein * 3.0 - (1.0 - pixelUV.x) * 6.0 + time * 0.25) * 0.5 + 0.5;\n  rightTendril2 = smoothstep(0.75, 0.98, rightTendril2) * pow(max(0.0, pixelUV.x - 0.75), 1.5);\n  \n  // Combine right wisp\n  float rightBase = rightRibbon * (0.6 + rightMarble * 0.4 + rightStreams * 0.3);\n  float rightTendrils = rightTendril1 * 2.5 + rightTendril2 * 2.0;\n  float rightIntensity = rightBase + rightTendrils * 0.5;\n  rightIntensity *= smoothstep(0.3, 1.0, pixelUV.x); // Fade toward center\n  \n  // === FRAME MASK - keep center clear ===\n  vec2 center = pixelUV - 0.5;\n  center.x *= aspect * 0.6;\n  float centerDist = length(center);\n  float frameMask = smoothstep(0.08, u_edgeFade, centerDist);\n  float innerClear = smoothstep(0.28, 0.1, centerDist);\n  \n  leftIntensity *= frameMask;\n  rightIntensity *= frameMask;\n  \n  // === DITHERING for pixelated texture (more pronounced) ===\n  float dither = bayerDither(ditherCoord);\n  float ditherNoise = hash(ditherCoord * 0.25) * 0.35 + dither * 0.65;\n  float ditherFine = hash(ditherCoord * 1.5) * 0.3 + bayerDither(ditherCoord * 2.0) * 0.7;\n  \n  // Create multiple layers of dithered dots\n  float leftDot1 = step(dither * 0.25, leftIntensity * 0.45);\n  float leftDot2 = step(ditherNoise * 0.35, leftIntensity * 0.3);\n  float leftDot3 = step(ditherFine * 0.4, leftIntensity * 0.55);\n  float leftDithered = max(max(leftDot1, leftDot2 * 0.8), leftDot3 * 0.6);\n  \n  // Soft base + dithered overlay\n  float leftSoft = leftIntensity * 0.25;\n  float leftFinal = leftSoft + leftDithered * leftIntensity * 0.75;\n  \n  float rightDot1 = step(dither * 0.25, rightIntensity * 0.45);\n  float rightDot2 = step(ditherNoise * 0.35, rightIntensity * 0.3);\n  float rightDot3 = step(ditherFine * 0.4, rightIntensity * 0.55);\n  float rightDithered = max(max(rightDot1, rightDot2 * 0.8), rightDot3 * 0.6);\n  \n  float rightSoft = rightIntensity * 0.25;\n  float rightFinal = rightSoft + rightDithered * rightIntensity * 0.75;\n  \n  // === SATURATION VARIATION - concentrated in dithered areas ===\n  float leftSat = 0.1 + leftDithered * 0.6 + leftFinal * 0.8 + smoothstep(0.45, 0.9, leftVein) * 0.5;\n  float rightSat = 0.1 + rightDithered * 0.6 + rightFinal * 0.8 + smoothstep(0.45, 0.9, rightVein) * 0.5;\n  leftSat = clamp(leftSat, 0.0, 1.0);\n  rightSat = clamp(rightSat, 0.0, 1.0);\n  \n  // === COLORS ===\n  vec3 color = vec3(1.0);\n  \n  // Left wisp - blue/cyan spectrum\n  vec3 leftPale = mix(vec3(1.0), vec3(0.82, 0.9, 0.97), 0.2);\n  vec3 leftMid = mix(vec3(1.0), vec3(0.5, 0.72, 0.94), 0.55);\n  vec3 leftVivid = vec3(0.3, 0.55, 0.9);\n  vec3 leftAccent = vec3(0.4, 0.5, 0.82); // Purple accent for some spots\n  \n  vec3 leftColor = mix(leftPale, leftMid, pow(leftSat, 0.7));\n  leftColor = mix(leftColor, leftVivid, smoothstep(0.5, 0.95, leftSat) * leftDithered);\n  // Add purple accent in some spots\n  leftColor = mix(leftColor, leftAccent, smoothstep(0.6, 0.95, leftVein) * leftDithered * 0.4);\n  \n  // Right wisp - purple/lavender spectrum\n  vec3 rightPale = mix(vec3(1.0), vec3(0.88, 0.85, 0.96), 0.2);\n  vec3 rightMid = mix(vec3(1.0), vec3(0.65, 0.52, 0.88), 0.55);\n  vec3 rightVivid = vec3(0.48, 0.35, 0.82);\n  vec3 rightAccent = vec3(0.4, 0.55, 0.85); // Blue accent for some spots\n  \n  vec3 rightColor = mix(rightPale, rightMid, pow(rightSat, 0.7));\n  rightColor = mix(rightColor, rightVivid, smoothstep(0.5, 0.95, rightSat) * rightDithered);\n  // Add blue accent in some spots\n  rightColor = mix(rightColor, rightAccent, smoothstep(0.55, 0.9, rightMarble) * rightDithered * 0.35);\n  \n  // === COMBINE ===\n  color = mix(color, leftColor, leftFinal * 0.92);\n  color = mix(color, rightColor, rightFinal * 0.92);\n  \n  // Ensure center stays white\n  color = mix(color, vec3(1.0), innerClear);\n  \n  // Very subtle vignette\n  float vignette = 1.0 - centerDist * 0.03;\n  color *= vignette;\n  \n  fragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}`;\n\nfunction createShader(\n  gl: WebGL2RenderingContext,\n  type: number,\n  source: string\n): WebGLShader | null {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"Shader compile error:\", gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n}\n\nfunction createProgram(\n  gl: WebGL2RenderingContext,\n  vertexSource: string,\n  fragmentSource: string\n): WebGLProgram | null {\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n\n  if (!vertexShader || !fragmentShader) return null;\n\n  const program = gl.createProgram();\n  if (!program) return null;\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Program link error:\", gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    return null;\n  }\n\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n\n  return program;\n}\n\n// Convert hex color to RGB values (0-1 range)\nfunction hexToRgb(hex: string): [number, number, number] {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  if (!result) return [0.6, 0.7, 0.9]; // default blue\n  return [\n    parseInt(result[1], 16) / 255,\n    parseInt(result[2], 16) / 255,\n    parseInt(result[3], 16) / 255,\n  ];\n}\n\nexport interface ShaderBackgroundProps {\n  /** Primary color (appears on left side) - hex format */\n  color1?: string;\n  /** Secondary color (appears on right side) - hex format */\n  color2?: string;\n  /** Tertiary color (subtle overall tint) - hex format */\n  color3?: string;\n  /** Scale of the noise pattern (default: 2.0) */\n  noiseScale?: number;\n  /** Speed of the flowing animation (default: 0.15) */\n  flowSpeed?: number;\n  /** How far the colors extend from edges (0-1, default: 0.7) */\n  edgeFade?: number;\n  /** Additional CSS classes */\n  className?: string;\n  /** Inline styles */\n  style?: React.CSSProperties;\n  /** Children to render on top of the background */\n  children?: React.ReactNode;\n}\n\nexport function ShaderBackground({\n  color1 = \"#5a9fd4\", // Blue (left wisp)\n  color2 = \"#8b7cb8\", // Purple/lavender (right wisp)\n  color3 = \"#c8ddf0\", // Pale blue accent\n  noiseScale = 1.8,\n  flowSpeed = 0.08,\n  edgeFade = 0.4,\n  className,\n  style,\n  children,\n}: ShaderBackgroundProps) {\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const glRef = React.useRef<WebGL2RenderingContext | null>(null);\n  const programRef = React.useRef<WebGLProgram | null>(null);\n  const rafRef = React.useRef<number | null>(null);\n  const uniformLocationsRef = React.useRef<Record<string, WebGLUniformLocation | null>>({});\n\n  // Convert colors\n  const rgb1 = React.useMemo(() => hexToRgb(color1), [color1]);\n  const rgb2 = React.useMemo(() => hexToRgb(color2), [color2]);\n  const rgb3 = React.useMemo(() => hexToRgb(color3), [color3]);\n\n  // Initialize WebGL\n  React.useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const gl = canvas.getContext(\"webgl2\", {\n      alpha: false,\n      antialias: true,\n      powerPreference: \"low-power\",\n    });\n\n    if (!gl) {\n      console.error(\"WebGL2 not supported\");\n      return;\n    }\n\n    glRef.current = gl;\n\n    const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);\n    if (!program) return;\n\n    programRef.current = program;\n\n    // Setup position attribute\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n    const positionLocation = gl.getAttribLocation(program, \"a_position\");\n    gl.enableVertexAttribArray(positionLocation);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // Get uniform locations\n    uniformLocationsRef.current = {\n      u_time: gl.getUniformLocation(program, \"u_time\"),\n      u_resolution: gl.getUniformLocation(program, \"u_resolution\"),\n      u_color1: gl.getUniformLocation(program, \"u_color1\"),\n      u_color2: gl.getUniformLocation(program, \"u_color2\"),\n      u_color3: gl.getUniformLocation(program, \"u_color3\"),\n      u_noiseScale: gl.getUniformLocation(program, \"u_noiseScale\"),\n      u_flowSpeed: gl.getUniformLocation(program, \"u_flowSpeed\"),\n      u_edgeFade: gl.getUniformLocation(program, \"u_edgeFade\"),\n    };\n\n    return () => {\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n      if (gl && program) {\n        gl.deleteProgram(program);\n      }\n    };\n  }, []);\n\n  // Handle resize\n  React.useEffect(() => {\n    const container = containerRef.current;\n    const canvas = canvasRef.current;\n    if (!container || !canvas) return;\n\n    const handleResize = () => {\n      const rect = container.getBoundingClientRect();\n      const pixelRatio = Math.min(window.devicePixelRatio, 2);\n      canvas.width = rect.width * pixelRatio;\n      canvas.height = rect.height * pixelRatio;\n\n      const gl = glRef.current;\n      if (gl) {\n        gl.viewport(0, 0, canvas.width, canvas.height);\n      }\n    };\n\n    handleResize();\n\n    const resizeObserver = new ResizeObserver(handleResize);\n    resizeObserver.observe(container);\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  // Render loop\n  React.useEffect(() => {\n    const gl = glRef.current;\n    const program = programRef.current;\n    const locations = uniformLocationsRef.current;\n    const canvas = canvasRef.current;\n\n    if (!gl || !program || !canvas) return;\n\n    let startTime = performance.now();\n\n    const render = () => {\n      const currentTime = (performance.now() - startTime) * 0.001;\n\n      gl.clearColor(1, 1, 1, 1);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      gl.useProgram(program);\n\n      // Set uniforms\n      if (locations.u_time) {\n        gl.uniform1f(locations.u_time, currentTime);\n      }\n      if (locations.u_resolution) {\n        gl.uniform2f(locations.u_resolution, canvas.width, canvas.height);\n      }\n      if (locations.u_color1) {\n        gl.uniform3fv(locations.u_color1, rgb1);\n      }\n      if (locations.u_color2) {\n        gl.uniform3fv(locations.u_color2, rgb2);\n      }\n      if (locations.u_color3) {\n        gl.uniform3fv(locations.u_color3, rgb3);\n      }\n      if (locations.u_noiseScale) {\n        gl.uniform1f(locations.u_noiseScale, noiseScale);\n      }\n      if (locations.u_flowSpeed) {\n        gl.uniform1f(locations.u_flowSpeed, flowSpeed);\n      }\n      if (locations.u_edgeFade) {\n        gl.uniform1f(locations.u_edgeFade, edgeFade);\n      }\n\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n      rafRef.current = requestAnimationFrame(render);\n    };\n\n    rafRef.current = requestAnimationFrame(render);\n\n    return () => {\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n    };\n  }, [rgb1, rgb2, rgb3, noiseScale, flowSpeed, edgeFade]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(\"relative w-full h-full overflow-hidden\", className)}\n      style={style}\n    >\n      <canvas\n        ref={canvasRef}\n        className=\"absolute inset-0 w-full h-full pointer-events-none\"\n        style={{ opacity: 0.9 }}\n      />\n      {children && <div className=\"relative z-10\">{children}</div>}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/ui/shader-background.tsx"
    }
  ],
  "type": "registry:component"
}