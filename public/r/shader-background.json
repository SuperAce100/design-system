{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "shader-background",
  "title": "Shader Background",
  "description": "An ethereal, flowing WebGL background with subtle animation. Inspired by exa.ai.",
  "dependencies": [],
  "files": [
    {
      "path": "registry/new-york/blocks/shader-background/shader-background.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { cn } from \"@/lib/utils\";\n\n// Vertex shader\nconst vertexShaderSource = `#version 300 es\nin vec4 a_position;\nout vec2 v_texCoord;\n\nvoid main() {\n  gl_Position = a_position;\n  v_texCoord = a_position.xy * 0.5 + 0.5;\n}`;\n\n// Fragment shader for ethereal flowing background\n// Features: two main marble wisps, flowing veined texture, saturation variation, framing effect\nconst fragmentShaderSource = `#version 300 es\nprecision highp float;\n\nin vec2 v_texCoord;\nout vec4 fragColor;\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec3 u_color1;\nuniform vec3 u_color2;\nuniform vec3 u_color3;\nuniform float u_noiseScale;\nuniform float u_flowSpeed;\nuniform float u_edgeFade;\n\n// Hash for dithering\nfloat hash(vec2 p) {\n  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Simplex 2D noise\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n                      -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n                   + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n                          dot(x12.zw,x12.zw)), 0.0);\n  m = m*m;\n  m = m*m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// FBM for marble texture\nfloat fbm(vec2 p, float time) {\n  float value = 0.0;\n  float amplitude = 0.5;\n  float frequency = 1.0;\n  \n  for (int i = 0; i < 6; i++) {\n    value += amplitude * snoise(p * frequency + vec2(0.0, time * 0.02));\n    frequency *= 2.0;\n    amplitude *= 0.5;\n  }\n  \n  return value;\n}\n\n// Domain warping for marble effect\nvec2 warp(vec2 p, float time) {\n  vec2 q = vec2(\n    fbm(p + vec2(0.0, 0.0), time),\n    fbm(p + vec2(5.2, 1.3), time)\n  );\n  \n  vec2 r = vec2(\n    fbm(p + 4.0 * q + vec2(1.7, 9.2), time),\n    fbm(p + 4.0 * q + vec2(8.3, 2.8), time)\n  );\n  \n  return r;\n}\n\n// Marble veining pattern\nfloat marble(vec2 p, float time) {\n  vec2 w = warp(p * 0.5, time);\n  float n = fbm(p + 2.0 * w, time);\n  \n  // Create veining effect\n  float veins = sin((p.x + p.y * 0.5 + n * 3.0) * 3.14159);\n  veins = pow(abs(veins), 0.3);\n  \n  return mix(n * 0.5 + 0.5, veins, 0.6);\n}\n\n// Bayer dithering\nfloat bayerDither(vec2 pos) {\n  vec2 p = mod(pos, 8.0);\n  float a = mod(p.x + p.y * 2.0, 4.0);\n  float b = mod(p.x * 2.0 + p.y, 4.0);\n  return (a * 4.0 + b) / 64.0;\n}\n\nvoid main() {\n  vec2 uv = v_texCoord;\n  float aspect = u_resolution.x / u_resolution.y;\n  \n  float time = u_time * u_flowSpeed;\n  \n  // Pixelation for dithered texture\n  float pixelSize = 2.0;\n  vec2 pixelCoord = uv * u_resolution;\n  vec2 pixelUV = floor(pixelCoord / pixelSize) * pixelSize / u_resolution;\n  vec2 ditherCoord = floor(pixelCoord / pixelSize);\n  \n  // Scale for noise\n  vec2 noiseUV = vec2(pixelUV.x * aspect, pixelUV.y) * u_noiseScale;\n  \n  // Noise for smoke and patterns\n  float leftWarp = fbm(noiseUV * 1.2 + vec2(time * 0.02, 0.0), time);\n  float leftWarp2 = fbm(noiseUV * 2.0 + vec2(-1.0, time * 0.015), time);\n  float rightWarp = fbm(noiseUV * 1.2 + vec2(5.0, time * 0.02), time);\n  float rightWarp2 = fbm(noiseUV * 2.0 + vec2(6.0, time * 0.015), time);\n  \n  // Marble textures for detail\n  float leftMarble = marble(noiseUV + vec2(-2.0, 0.0), time);\n  float leftVein = marble(noiseUV * 1.5 + vec2(-1.0, 1.0), time * 0.8);\n  float rightMarble = marble(noiseUV + vec2(3.0, 1.0), time * 0.9);\n  float rightVein = marble(noiseUV * 1.4 + vec2(4.0, -1.0), time * 0.7);\n  \n  // ============================================================\n  // LAYER 1: BASE SMOKE LAYER (soft, pale, flowing wisps)\n  // ============================================================\n  \n  // Left smoke - soft flowing shape\n  float leftSmokeCurve = 0.15 + sin(pixelUV.y * 2.2 + leftWarp * 0.6) * 0.1;\n  float leftSmokeX = pixelUV.x - leftSmokeCurve;\n  float leftSmoke = smoothstep(-0.05, 0.2, leftSmokeX) * smoothstep(0.5, 0.15, leftSmokeX);\n  leftSmoke *= 0.5 + leftMarble * 0.5;\n  leftSmoke *= smoothstep(0.65, 0.0, pixelUV.x);\n  \n  // Add smoke tendrils\n  float leftSmokeTendril1 = sin(pixelUV.y * 6.0 + leftWarp * 3.0 + pixelUV.x * 8.0) * 0.5 + 0.5;\n  leftSmokeTendril1 = smoothstep(0.55, 0.85, leftSmokeTendril1) * pow(max(0.0, 0.35 - pixelUV.x), 1.0);\n  \n  float leftSmokeTendril2 = sin(pixelUV.y * 4.0 + leftWarp2 * 2.5 - pixelUV.x * 5.0) * 0.5 + 0.5;\n  leftSmokeTendril2 = smoothstep(0.5, 0.8, leftSmokeTendril2) * pow(max(0.0, 0.4 - pixelUV.x), 0.8);\n  \n  float leftSmokeIntensity = leftSmoke + leftSmokeTendril1 * 0.6 + leftSmokeTendril2 * 0.5;\n  \n  // Right smoke\n  float rightSmokeCurve = 0.15 + sin((1.0 - pixelUV.y) * 2.2 + rightWarp * 0.6) * 0.1;\n  float rightSmokeX = (1.0 - pixelUV.x) - rightSmokeCurve;\n  float rightSmoke = smoothstep(-0.05, 0.2, rightSmokeX) * smoothstep(0.5, 0.15, rightSmokeX);\n  rightSmoke *= 0.5 + rightMarble * 0.5;\n  rightSmoke *= smoothstep(0.35, 1.0, pixelUV.x);\n  \n  // Right smoke tendrils\n  float rightSmokeTendril1 = sin((1.0 - pixelUV.y) * 6.0 + rightWarp * 3.0 + (1.0 - pixelUV.x) * 8.0) * 0.5 + 0.5;\n  rightSmokeTendril1 = smoothstep(0.55, 0.85, rightSmokeTendril1) * pow(max(0.0, pixelUV.x - 0.65), 1.0);\n  \n  float rightSmokeTendril2 = sin((1.0 - pixelUV.y) * 4.0 + rightWarp2 * 2.5 - (1.0 - pixelUV.x) * 5.0) * 0.5 + 0.5;\n  rightSmokeTendril2 = smoothstep(0.5, 0.8, rightSmokeTendril2) * pow(max(0.0, pixelUV.x - 0.6), 0.8);\n  \n  float rightSmokeIntensity = rightSmoke + rightSmokeTendril1 * 0.6 + rightSmokeTendril2 * 0.5;\n  \n  // ============================================================\n  // LAYER 2: COLORFUL DITHER LAYER (concentrated, saturated dots)\n  // ============================================================\n  \n  // Left dither pattern - thinner, more concentrated streams\n  float leftDitherCurve = 0.1 + sin(pixelUV.y * 3.5 + leftWarp * 1.2) * 0.12 + leftWarp2 * 0.08;\n  float leftDitherX = pixelUV.x - leftDitherCurve;\n  float leftDitherRibbon = smoothstep(-0.02, 0.12, leftDitherX) * smoothstep(0.32, 0.08, leftDitherX);\n  \n  // Thin streaming lines for dither\n  float leftLine1 = sin(pixelUV.y * 18.0 + leftWarp * 7.0 + pixelUV.x * 12.0) * 0.5 + 0.5;\n  float leftLine2 = sin(pixelUV.y * 25.0 + leftWarp2 * 5.0 - pixelUV.x * 8.0) * 0.5 + 0.5;\n  float leftLine3 = sin(pixelUV.y * 32.0 + leftVein * 4.0 + pixelUV.x * 15.0) * 0.5 + 0.5;\n  float leftLine4 = sin(pixelUV.y * 12.0 + leftMarble * 6.0 - pixelUV.x * 6.0) * 0.5 + 0.5;\n  \n  float leftLines = smoothstep(0.72, 0.97, leftLine1) * 0.7 +\n                    smoothstep(0.75, 0.98, leftLine2) * 0.6 +\n                    smoothstep(0.78, 0.99, leftLine3) * 0.5 +\n                    smoothstep(0.68, 0.92, leftLine4) * 0.4;\n  \n  float leftDitherIntensity = leftDitherRibbon * (0.4 + leftLines * 0.8);\n  leftDitherIntensity *= smoothstep(0.55, 0.0, pixelUV.x);\n  \n  // Add concentrated spots\n  float leftSpot = smoothstep(0.6, 0.95, leftVein) * pow(max(0.0, 0.25 - pixelUV.x), 1.2);\n  leftDitherIntensity += leftSpot * 0.8;\n  \n  // Right dither pattern\n  float rightDitherCurve = 0.1 + sin((1.0 - pixelUV.y) * 3.5 + rightWarp * 1.2) * 0.12 + rightWarp2 * 0.08;\n  float rightDitherX = (1.0 - pixelUV.x) - rightDitherCurve;\n  float rightDitherRibbon = smoothstep(-0.02, 0.12, rightDitherX) * smoothstep(0.32, 0.08, rightDitherX);\n  \n  // Thin streaming lines for right dither\n  float rightLine1 = sin((1.0 - pixelUV.y) * 18.0 + rightWarp * 7.0 + (1.0 - pixelUV.x) * 12.0) * 0.5 + 0.5;\n  float rightLine2 = sin((1.0 - pixelUV.y) * 24.0 + rightWarp2 * 5.0 - (1.0 - pixelUV.x) * 8.0) * 0.5 + 0.5;\n  float rightLine3 = sin((1.0 - pixelUV.y) * 31.0 + rightVein * 4.0 + (1.0 - pixelUV.x) * 15.0) * 0.5 + 0.5;\n  float rightLine4 = sin((1.0 - pixelUV.y) * 11.0 + rightMarble * 6.0 - (1.0 - pixelUV.x) * 6.0) * 0.5 + 0.5;\n  \n  float rightLines = smoothstep(0.72, 0.97, rightLine1) * 0.7 +\n                     smoothstep(0.75, 0.98, rightLine2) * 0.6 +\n                     smoothstep(0.78, 0.99, rightLine3) * 0.5 +\n                     smoothstep(0.68, 0.92, rightLine4) * 0.4;\n  \n  float rightDitherIntensity = rightDitherRibbon * (0.4 + rightLines * 0.8);\n  rightDitherIntensity *= smoothstep(0.45, 1.0, pixelUV.x);\n  \n  // Add concentrated spots\n  float rightSpot = smoothstep(0.6, 0.95, rightVein) * pow(max(0.0, pixelUV.x - 0.75), 1.2);\n  rightDitherIntensity += rightSpot * 0.8;\n  \n  // ============================================================\n  // FRAME MASK - keep center clear\n  // ============================================================\n  vec2 center = pixelUV - 0.5;\n  center.x *= aspect * 0.6;\n  float centerDist = length(center);\n  float frameMask = smoothstep(0.08, u_edgeFade, centerDist);\n  float innerClear = smoothstep(0.25, 0.08, centerDist);\n  \n  leftSmokeIntensity *= frameMask;\n  rightSmokeIntensity *= frameMask;\n  leftDitherIntensity *= frameMask;\n  rightDitherIntensity *= frameMask;\n  \n  // ============================================================\n  // APPLY DITHERING to the dither layer\n  // ============================================================\n  float dither = bayerDither(ditherCoord);\n  float ditherNoise = hash(ditherCoord * 0.2) * 0.3 + dither * 0.7;\n  float ditherFine = hash(ditherCoord * 1.8) * 0.25 + bayerDither(ditherCoord * 2.5) * 0.75;\n  \n  // Multiple dither thresholds for varied dot density\n  float leftDot1 = step(dither * 0.2, leftDitherIntensity * 0.4);\n  float leftDot2 = step(ditherNoise * 0.3, leftDitherIntensity * 0.28);\n  float leftDot3 = step(ditherFine * 0.35, leftDitherIntensity * 0.5);\n  float leftDithered = max(max(leftDot1, leftDot2 * 0.85), leftDot3 * 0.7);\n  \n  float rightDot1 = step(dither * 0.2, rightDitherIntensity * 0.4);\n  float rightDot2 = step(ditherNoise * 0.3, rightDitherIntensity * 0.28);\n  float rightDot3 = step(ditherFine * 0.35, rightDitherIntensity * 0.5);\n  float rightDithered = max(max(rightDot1, rightDot2 * 0.85), rightDot3 * 0.7);\n  \n  // ============================================================\n  // COLORS - separate for each layer\n  // ============================================================\n  vec3 color = vec3(1.0);\n  \n  // --- LAYER 1: Smoke colors (very pale, subtle) ---\n  vec3 leftSmokeColor = mix(vec3(1.0), vec3(0.88, 0.92, 0.98), 0.15); // Very pale blue tint\n  vec3 rightSmokeColor = mix(vec3(1.0), vec3(0.92, 0.9, 0.96), 0.15); // Very pale lavender tint\n  \n  // Apply smoke layer first (base)\n  color = mix(color, leftSmokeColor, leftSmokeIntensity * 0.5);\n  color = mix(color, rightSmokeColor, rightSmokeIntensity * 0.5);\n  \n  // --- LAYER 2: Dither colors (more saturated, concentrated) ---\n  // Saturation varies based on intensity and vein patterns\n  float leftSat = 0.3 + leftDithered * 0.5 + smoothstep(0.5, 0.9, leftVein) * 0.3;\n  float rightSat = 0.3 + rightDithered * 0.5 + smoothstep(0.5, 0.9, rightVein) * 0.3;\n  \n  // Left dither - blue/cyan with purple accents\n  vec3 leftDitherPale = mix(vec3(1.0), vec3(0.7, 0.85, 0.98), 0.35);\n  vec3 leftDitherMid = mix(vec3(1.0), vec3(0.45, 0.68, 0.94), 0.65);\n  vec3 leftDitherVivid = vec3(0.28, 0.52, 0.9);\n  vec3 leftDitherAccent = vec3(0.45, 0.45, 0.85); // Purple accent\n  \n  vec3 leftDitherColor = mix(leftDitherPale, leftDitherMid, leftSat);\n  leftDitherColor = mix(leftDitherColor, leftDitherVivid, smoothstep(0.6, 1.0, leftSat) * leftDithered);\n  leftDitherColor = mix(leftDitherColor, leftDitherAccent, smoothstep(0.65, 0.95, leftVein) * leftDithered * 0.5);\n  \n  // Right dither - purple/lavender with blue accents\n  vec3 rightDitherPale = mix(vec3(1.0), vec3(0.85, 0.78, 0.96), 0.35);\n  vec3 rightDitherMid = mix(vec3(1.0), vec3(0.62, 0.48, 0.88), 0.65);\n  vec3 rightDitherVivid = vec3(0.45, 0.3, 0.82);\n  vec3 rightDitherAccent = vec3(0.38, 0.52, 0.88); // Blue accent\n  \n  vec3 rightDitherColor = mix(rightDitherPale, rightDitherMid, rightSat);\n  rightDitherColor = mix(rightDitherColor, rightDitherVivid, smoothstep(0.6, 1.0, rightSat) * rightDithered);\n  rightDitherColor = mix(rightDitherColor, rightDitherAccent, smoothstep(0.6, 0.92, rightMarble) * rightDithered * 0.45);\n  \n  // Apply dither layer on top of smoke\n  color = mix(color, leftDitherColor, leftDithered * leftDitherIntensity * 0.95);\n  color = mix(color, rightDitherColor, rightDithered * rightDitherIntensity * 0.95);\n  \n  // Ensure center stays white\n  color = mix(color, vec3(1.0), innerClear);\n  \n  // Very subtle vignette\n  float vignette = 1.0 - centerDist * 0.025;\n  color *= vignette;\n  \n  fragColor = vec4(clamp(color, 0.0, 1.0), 1.0);\n}`;\n\nfunction createShader(\n  gl: WebGL2RenderingContext,\n  type: number,\n  source: string\n): WebGLShader | null {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"Shader compile error:\", gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n}\n\nfunction createProgram(\n  gl: WebGL2RenderingContext,\n  vertexSource: string,\n  fragmentSource: string\n): WebGLProgram | null {\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);\n\n  if (!vertexShader || !fragmentShader) return null;\n\n  const program = gl.createProgram();\n  if (!program) return null;\n\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Program link error:\", gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    return null;\n  }\n\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n\n  return program;\n}\n\n// Convert hex color to RGB values (0-1 range)\nfunction hexToRgb(hex: string): [number, number, number] {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  if (!result) return [0.6, 0.7, 0.9]; // default blue\n  return [\n    parseInt(result[1], 16) / 255,\n    parseInt(result[2], 16) / 255,\n    parseInt(result[3], 16) / 255,\n  ];\n}\n\nexport interface ShaderBackgroundProps {\n  /** Primary color (appears on left side) - hex format */\n  color1?: string;\n  /** Secondary color (appears on right side) - hex format */\n  color2?: string;\n  /** Tertiary color (subtle overall tint) - hex format */\n  color3?: string;\n  /** Scale of the noise pattern (default: 2.0) */\n  noiseScale?: number;\n  /** Speed of the flowing animation (default: 0.15) */\n  flowSpeed?: number;\n  /** How far the colors extend from edges (0-1, default: 0.7) */\n  edgeFade?: number;\n  /** Additional CSS classes */\n  className?: string;\n  /** Inline styles */\n  style?: React.CSSProperties;\n  /** Children to render on top of the background */\n  children?: React.ReactNode;\n}\n\nexport function ShaderBackground({\n  color1 = \"#5a9fd4\", // Blue (left wisp)\n  color2 = \"#8b7cb8\", // Purple/lavender (right wisp)\n  color3 = \"#c8ddf0\", // Pale blue accent\n  noiseScale = 1.8,\n  flowSpeed = 0.08,\n  edgeFade = 0.4,\n  className,\n  style,\n  children,\n}: ShaderBackgroundProps) {\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  const containerRef = React.useRef<HTMLDivElement>(null);\n  const glRef = React.useRef<WebGL2RenderingContext | null>(null);\n  const programRef = React.useRef<WebGLProgram | null>(null);\n  const rafRef = React.useRef<number | null>(null);\n  const uniformLocationsRef = React.useRef<Record<string, WebGLUniformLocation | null>>({});\n\n  // Convert colors\n  const rgb1 = React.useMemo(() => hexToRgb(color1), [color1]);\n  const rgb2 = React.useMemo(() => hexToRgb(color2), [color2]);\n  const rgb3 = React.useMemo(() => hexToRgb(color3), [color3]);\n\n  // Initialize WebGL\n  React.useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const gl = canvas.getContext(\"webgl2\", {\n      alpha: false,\n      antialias: true,\n      powerPreference: \"low-power\",\n    });\n\n    if (!gl) {\n      console.error(\"WebGL2 not supported\");\n      return;\n    }\n\n    glRef.current = gl;\n\n    const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);\n    if (!program) return;\n\n    programRef.current = program;\n\n    // Setup position attribute\n    const positionBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);\n\n    const positionLocation = gl.getAttribLocation(program, \"a_position\");\n    gl.enableVertexAttribArray(positionLocation);\n    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n    // Get uniform locations\n    uniformLocationsRef.current = {\n      u_time: gl.getUniformLocation(program, \"u_time\"),\n      u_resolution: gl.getUniformLocation(program, \"u_resolution\"),\n      u_color1: gl.getUniformLocation(program, \"u_color1\"),\n      u_color2: gl.getUniformLocation(program, \"u_color2\"),\n      u_color3: gl.getUniformLocation(program, \"u_color3\"),\n      u_noiseScale: gl.getUniformLocation(program, \"u_noiseScale\"),\n      u_flowSpeed: gl.getUniformLocation(program, \"u_flowSpeed\"),\n      u_edgeFade: gl.getUniformLocation(program, \"u_edgeFade\"),\n    };\n\n    return () => {\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n      if (gl && program) {\n        gl.deleteProgram(program);\n      }\n    };\n  }, []);\n\n  // Handle resize\n  React.useEffect(() => {\n    const container = containerRef.current;\n    const canvas = canvasRef.current;\n    if (!container || !canvas) return;\n\n    const handleResize = () => {\n      const rect = container.getBoundingClientRect();\n      const pixelRatio = Math.min(window.devicePixelRatio, 2);\n      canvas.width = rect.width * pixelRatio;\n      canvas.height = rect.height * pixelRatio;\n\n      const gl = glRef.current;\n      if (gl) {\n        gl.viewport(0, 0, canvas.width, canvas.height);\n      }\n    };\n\n    handleResize();\n\n    const resizeObserver = new ResizeObserver(handleResize);\n    resizeObserver.observe(container);\n\n    return () => {\n      resizeObserver.disconnect();\n    };\n  }, []);\n\n  // Render loop\n  React.useEffect(() => {\n    const gl = glRef.current;\n    const program = programRef.current;\n    const locations = uniformLocationsRef.current;\n    const canvas = canvasRef.current;\n\n    if (!gl || !program || !canvas) return;\n\n    let startTime = performance.now();\n\n    const render = () => {\n      const currentTime = (performance.now() - startTime) * 0.001;\n\n      gl.clearColor(1, 1, 1, 1);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      gl.useProgram(program);\n\n      // Set uniforms\n      if (locations.u_time) {\n        gl.uniform1f(locations.u_time, currentTime);\n      }\n      if (locations.u_resolution) {\n        gl.uniform2f(locations.u_resolution, canvas.width, canvas.height);\n      }\n      if (locations.u_color1) {\n        gl.uniform3fv(locations.u_color1, rgb1);\n      }\n      if (locations.u_color2) {\n        gl.uniform3fv(locations.u_color2, rgb2);\n      }\n      if (locations.u_color3) {\n        gl.uniform3fv(locations.u_color3, rgb3);\n      }\n      if (locations.u_noiseScale) {\n        gl.uniform1f(locations.u_noiseScale, noiseScale);\n      }\n      if (locations.u_flowSpeed) {\n        gl.uniform1f(locations.u_flowSpeed, flowSpeed);\n      }\n      if (locations.u_edgeFade) {\n        gl.uniform1f(locations.u_edgeFade, edgeFade);\n      }\n\n      gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n      rafRef.current = requestAnimationFrame(render);\n    };\n\n    rafRef.current = requestAnimationFrame(render);\n\n    return () => {\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n      }\n    };\n  }, [rgb1, rgb2, rgb3, noiseScale, flowSpeed, edgeFade]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(\"relative w-full h-full overflow-hidden\", className)}\n      style={style}\n    >\n      <canvas\n        ref={canvasRef}\n        className=\"absolute inset-0 w-full h-full pointer-events-none\"\n        style={{ opacity: 0.9 }}\n      />\n      {children && <div className=\"relative z-10\">{children}</div>}\n    </div>\n  );\n}\n",
      "type": "registry:component",
      "target": "components/ui/shader-background.tsx"
    }
  ],
  "type": "registry:component"
}